from DBConnect import DBConnect
from ImageCollection import ImageCollection
from Properties import Properties
from Singleton import Singleton
from weakref import WeakValueDictionary
import threading
import wx
import numpy
from heapq import heappush, heappop

db = DBConnect.getInstance()
p = Properties.getInstance()

class List(list): pass

class TileCollection(Singleton):
    '''
    Main access point for loading tiles through the TileLoader.
    '''
    def __init__(self):
        self.tileData = WeakValueDictionary()
        self.loadq    = []
        self.cv       = threading.Condition()
        # create a gray placeholder for unloaded images
        self.imagePlaceholder = List([numpy.zeros((int(p.image_tile_size),
                                              int(p.image_tile_size)))+0.1
                                 for channel in p.image_channel_colors])
        self.loader = TileLoader(self, None)
        

    def GetTileData(self, obKey, notify_window, priority=1):
        return self.GetTiles(self, [obKey], notify_window, priority=1)[0]
    
    def GetTiles(self, obKeys, notify_window, priority=1):
        self.loader.notify_window = notify_window
        tiles = []
        self.cv.acquire()
        for obKey in obKeys:
            td = self.tileData.get(obKey, None)
            if td:
                tiles += [td]
            else:                
                heappush(self.loadq, (priority, obKey))
                placeholder = List(self.imagePlaceholder)
                self.tileData[obKey] = placeholder
                tiles += [placeholder]
        self.cv.notify()
        self.cv.release()
        return tiles
    
    
# Define a result event which is generated by the image loader thread.
EVT_TILE_UPDATED_ID = wx.NewId()

def EVT_TILE_UPDATED(win, func):
    '''
    Any class that wishes to handle TileUpdatedEvents must call this function
    with itself as the first parameter, and a handler as the second parameter.
    '''
    win.Connect(-1, -1, EVT_TILE_UPDATED_ID, func)
   
class TileUpdatedEvent(wx.PyEvent):
    '''
    This event type is posted whenever an ImageTile has been updated by the
    TileLoader thread.
    '''
    def __init__(self, data):
        wx.PyEvent.__init__(self)
        self.SetEventType(EVT_TILE_UPDATED_ID)
        self.data = data
    


class TileLoader(threading.Thread):
    '''
    This thread is owned by the TileCollection singleton and is kept running
    for the duration of the app execution. Whenever TileCollection has obKeys
    in it's load queue (loadq), it will remove them from the queue and fetch
    the tile data for them. The tile data is then written back into 
    TileCollection's tileData dict over the existing placeholder. Finally an
    event is posted to the ClassifierGUI to tell it to refresh the tiles.
    '''
    def __init__(self, tc, notify_window):
        threading.Thread.__init__(self)
        self.notify_window = notify_window
        self.tile_collection = tc
        self._want_abort = False
        self.start()
    
    def run(self):
        image_collection = ImageCollection.getInstance(p)
        while 1:
            self.tile_collection.cv.acquire()
            # If there are no objects in the queue then wait
            if not self.tile_collection.loadq:
                self.tile_collection.cv.wait()
            if self._want_abort:
                return
            obKey = heappop(self.tile_collection.loadq)[1]
            self.tile_collection.cv.release()

            # Make sure tile hasn't been deleted outside this thread
            if not self.tile_collection.tileData.get(obKey, None):
                continue

            newData = image_collection.FetchTile(obKey)
            tile_data = self.tile_collection.tileData.get(obKey, None)
            # Make sure tile hasn't been deleted outside this thread
            if tile_data:
                # copy each channel
                for i in range(len(tile_data)):
                    tile_data[i] = newData[i]
                wx.PostEvent(self.notify_window, TileUpdatedEvent(obKey))

    def abort(self):
        self.tile_collection.cv.acquire()
        self._want_abort = True
        self.tile_collection.cv.notify()
        self.tile_collection.cv.release()
        



################# FOR TESTING ##########################
if __name__ == "__main__":
    app = wx.PySimpleApp()

    
    from DataModel import DataModel
    p = Properties.getInstance()
    p.LoadFile('../properties/nirht_test.properties')
    db = DBConnect.getInstance()
    db.Connect(db_host=p.db_host, db_user=p.db_user, db_passwd=p.db_passwd, db_name=p.db_name)
    dm = DataModel.getInstance()
    dm.PopulateModel()
    
    test = TileCollection.getInstance()
    
    f =  wx.Frame(None)
    for i in xrange(100):
        obKey = dm.GetRandomObject()
        test.GetTileData((0,1,1), f)
        
    for t in threading.enumerate():
        if t != threading.currentThread():
            t.abort()
    f.Destroy()
    
    app.MainLoop()
